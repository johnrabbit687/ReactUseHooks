---
templateKey: post
title: useWhyDidYouUpdate
date: "2019-02-21"
gist: https://gist.github.com/gragland/fe89992181663d5e46d024dec8a8e5e6
sandbox: https://codesandbox.io/s/kx83n7201o
code: "import { useState, useEffect, useRef } from 'react';\r\n\r\n\/\/ Let's pretend this <Counter> component is expensive to re-render so ...\r\n\/\/ ... we wrap with React.memo, but we're still seeing performance issues :\/\r\n\/\/ So we add useWhyDidYouUpdate and check our console to see what's going on.\r\nconst Counter = React.memo(props => {\r\n  useWhyDidYouUpdate('Counter', props);\r\n  return <div style={props.style}>{props.count}<\/div>;\r\n});\r\n\r\nfunction App() {\r\n  const [count, setCount] = useState(0);\r\n  const [userId, setUserId] = useState(0);\r\n\r\n  \/\/ Our console output tells use that the style prop for <Counter> ...\r\n  \/\/ ... changes on every render, even when we only change userId state by ...\r\n  \/\/ ... clicking the \"switch user\" button. Oh of course! That's because the\r\n  \/\/ ... counterStyle object is being re-created on every render.\r\n  \/\/ Thanks to our hook we figured this out and realized we should probably ...\r\n  \/\/ ... move this object outside of the component body.\r\n  const counterStyle = {\r\n    fontSize: '3rem',\r\n    color: 'red'\r\n  };\r\n\r\n  return (\r\n    <div>\r\n      <div className=\"counter\">\r\n        <Counter count={count} style={counterStyle} \/>\r\n        <button onClick={() => setCount(count + 1)}>Increment<\/button>\r\n      <\/div>\r\n      <div className=\"user\">\r\n        <img src={`http:\/\/i.pravatar.cc\/80?img=${userId}`} \/>\r\n        <button onClick={() => setUserId(userId + 1)}>Switch User<\/button>\r\n      <\/div>\r\n    <\/div>\r\n  );\r\n}\r\n\r\n\/\/ Hook\r\nfunction useWhyDidYouUpdate(name, props) {\r\n  \/\/ Get a mutable ref object where we can store props ...\r\n  \/\/ ... for comparison next time this hook runs.\r\n  const previousProps = useRef();\r\n\r\n  useEffect(() => {\r\n    if (previousProps.current) {\r\n      \/\/ Get all keys from previous and current props\r\n      const allKeys = Object.keys({ ...previousProps.current, ...props });\r\n      \/\/ Use this object to keep track of changed props\r\n      const changesObj = {};\r\n      \/\/ Iterate through keys\r\n      allKeys.forEach(key => {\r\n        \/\/ If previous is different from current\r\n        if (previousProps.current[key] !== props[key]) {\r\n          \/\/ Add to changesObj\r\n          changesObj[key] = {\r\n            from: previousProps.current[key],\r\n            to: props[key]\r\n          };\r\n        }\r\n      });\r\n\r\n      \/\/ If changesObj not empty then output to console\r\n      if (Object.keys(changesObj).length) {\r\n        console.log('[why-did-you-update]', name, changesObj);\r\n      }\r\n    }\r\n\r\n    \/\/ Finally update previousProps with current props for next hook call\r\n    previousProps.current = props;\r\n  });\r\n}"
---

This hook makes it easy to see which prop changes are causing a component to re-render. If a function is particularly expensive to run and you know it renders the same results given the same props you can use the `React.memo` higher order component, as we've done with the `Counter` component in the below example. In this case if you're still seeing re-renders that seem unnecessary you can drop in the `useWhyDidYouUpdate` hook and check your console to see which props changed between renders and view their previous/current values. Pretty nifty huh?
<br/><br/>
A huge thanks to Bruno Lemos for the [idea and original code](https://twitter.com/brunolemos/status/1090377532845801473). You can also see it in action in the [CodeSandbox demo](https://codesandbox.io/s/kx83n7201o).
